{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-the-brown-lab-documentation","title":"Welcome to the Brown Lab Documentation!","text":"<p>This documentation serves as a collection of reference guides for the Brown Lab at Virginia Tech. Here, you will find resources on the analytical tools and techniques most commonly used in the lab to aid your research. These pages aim to be detailed while still broadly applicable to most projects with some adaptation, if needed.</p> <p>See an issue, or want to help out? Learn how to contribute and reach out to Jonathan Briganti (jonbrig@vt.edu) to get started.</p> <p>Check out the lab's other resources:</p> <ul> <li>Brown Lab Website</li> <li>Brown Lab OSF</li> </ul>"},{"location":"ARC/","title":"ARC Resources Homepage","text":""},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/","title":"GROMACS Version Management &amp; Installation","text":""},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#introduction","title":"Introduction","text":"<p>GROMACS is the main simulation engine used in our lab for performing MD simulations. Separate installations are required for both different clusters (i.e. Tinkercliffs, Infer) and for different partitions (i.e. v100, p100, etc.). This page documents how GROMACS installations and versions are managed and installed. </p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#gromacs-version-list","title":"GROMACS Version List","text":"<p>To load any GROMACS version, the <code>$MODULEPATH</code> environment variable must be modified as follows: * Infer: <code>export MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all</code> * Tinkercliffs: <code>export MODULEPATH=$MODULEPATH:/projects/bevanlab/software/tinkercliffs/modules/modules/tinkercliffs-rome/all</code> * OWL: <code>export MODULEPATH=$MODULEPATH:/projects/bevanlab/software/tinkercliffs/modules/modules/owl-genoa/all</code></p> Cluster Partition Load Syntax Versions GPU-Enabled? MDRun executable Infer v100_normal_qv100_dev_q <code>module load gromacs-v100/20XX.X</code> 2018.12019.12020.32020.42024.4 Yes <code>gmx mdrun</code> Infer p100_normal_qp100_dev_q <code>module load gromacs-p100/20XX.X</code> 2019.32020.42020.4 Yes <code>gmx mdrun</code> Infer t4_normal_qt4_dev_q <code>module load gromacs-t4/20XX.X</code> 2019.32020.32020.4 Yes <code>gmx mdrun</code> Infer Login Node <code>module load gromacs/2020.4</code> 2020.4 No -- Tinkercliffs a100_normal_qa100_dev_q <code>module load gromacs/a100/20XX.X<code> 2020.42024.4 Yes <code>mdrun_gpu</code>(2020.4)<code>gmx mdrun</code>(2024.4) Tinkercliffs normal_qdev_q <code>module load gromacs/normal_q/2024.4<code> 2024.4 No -- OWL normal_qdev_q <code>module load gromacs/2024.4<code> 2024.4 No --"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#file-structure","title":"File Structure","text":"<p>The base folder for all shared software on ARC is <code>/projects/bevanlab/software</code>.  As of writing, the Brown Lab has access to two clusters through ARC: Infer and Tinkercliffs. Cluster-specific software, like GROMACS installations, are maintained in separate folders: <code>/projects/bevanlab/software/infer</code> and <code>/projects/bevanlab/software/tinkercliffs</code>. Partition-specific installs (modules) are maintained through using ARC's <code>setup_app</code> tool. <code>setup_app</code> automates the creation of file structures for specific apps that can be loaded modularly. Modules for Infer and Tinkercliffs are stored in <code>/projects/bevanlab/software/infer/modules</code> and <code>/projects/bevanlab/software/tinkercliffs/modules</code>, respectively. </p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#example-installation-protocols","title":"Example Installation Protocols","text":"<p>Note: for future GROMACS versions, the protocol as described here may not be exactly congruent in terms of module versions and CMake syntax.</p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#infer-installation-gpu-enabled-gromacs","title":"Infer Installation: GPU-Enabled GROMACS","text":""},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#downloading-gromacs-source-files","title":"Downloading GROMACS source-files","text":"<p>First, move into the Tinkercliffs software directory: <pre><code>[kelsieking23@infer1 ~]$ cd /projects/bevanlab/software/infer\n</code></pre></p> <p>Download GROMACS source files with <code>wget</code> and uncompress: <pre><code>[kelsieking23@infer1 infer]$ wget http://ftp.gromacs.org/pub/gromacs/gromacs-2024.4.tar.gz\n[kelsieking23@infer1 infer]$ tar -xzvf gromacs-2024.4.tar.gz\n</code></pre></p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#setting-up-with-setup_app","title":"Setting up with <code>setup_app</code>","text":"<p>To set up the initial file structure for install, we will run the <code>setup_app</code> tool. Make sure that you are still on the log-in node and that you have not yet requested an interactive session. This is important to keep consistency in the automatic generation of file paths. <pre><code>[kelsieking23@infer1 infer]$ setup_app --base /projects/bevanlab/software/infer/modules gromacs 2024.4\n</code></pre> <code>setup_app</code> will then prompt for user input. Type <code>y</code> for yes: <pre><code>Create directories /projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4 and /projects/bevanlab/software/infer/modules/modules/infer-skylake/all/gromacs-v100?\n</code></pre> After confirming, the following will be printed to the console: <pre><code>Done. To finish your build:\n 1. Install your app in /projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4/\n 2. Edit the modulefile in /projects/bevanlab/software/infer/modules/modules/infer-skylake/all/gromacs-v100/2024.4.lua\n    - Set or remove modules to load in the load() line\n    - Edit description and URL\n    - Check the variable names\n    - Edit paths (some packages don't have, e.g., an include/)\n\nNote: You specified a non-standard directory. You will need to add\n/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\nto MODULEPATH to be able to load the module.\nThis can be done by adding, e.g.,\n  export MODULEPATH=\"/projects/bevanlab/software/infer/modules/modules/infer-skylake/all:$MODULEPATH\"\nto your ~/.bashrc\n\nNote: You may need to refresh the cache, e.g.,\n  module --ignore_cache spider gromacs-v100\nto find the module the first time.\n</code></pre> Here, we have created a file structure for our GROMACS install, allowing the creation of an isolated GROMACS install for a specific Infer partition. In this example, we will be installing on the V100 partition. </p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#building-gromacs","title":"Building GROMACS","text":"<p>First, we must request an interactive session: <pre><code>[kelsieking23@infer1 infer]$ interact -p v100_normal_q -t 6:00:00 -N1 --ntasks=1 --cpus-per-task 24 -A bevanlab --gres=gpu:1\n</code></pre></p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#loading-dependencies","title":"Loading dependencies","text":"<p>To install GROMACS, we will need to load the correct versions of <code>CMake</code>, <code>CUDA</code>, and <code>GCC</code>. For each of these modules, there are several versions availble for loading on Infer. To see a list of available versions, we can use the command <code>module spider</code>. For example, the available versions for <code>CMake</code> are as follows:</p> <p><pre><code>[kelsieking23@inf092 infer]$ module spider CMake\n----------------------------------------------------------------------------------------------------------------------\n  CMake:\n----------------------------------------------------------------------------------------------------------------------\n    Description:\n      CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.\n\n     Versions:\n        CMake/3.15.3-GCCcore-8.3.0\n        CMake/3.16.4-GCCcore-9.3.0\n        CMake/3.18.4-GCCcore-10.2.0\n        CMake/3.20.1-GCCcore-10.3.0\n        CMake/3.21.1-GCCcore-11.2.0\n        CMake/3.22.1-GCCcore-11.2.0\n\n----------------------------------------------------------------------------------------------------------------------\n  For detailed information about a specific \"CMake\" package (including how to load the modules) use the module's full name. Note that names that have a trailing (E) are extensions provided by other modules.\n  For example:\n\n     $ module spider CMake/3.22.1-GCCcore-11.2.0\n----------------------------------------------------------------------------------------------------------------------\n</code></pre> Note that each <code>CMake</code> version has an associated <code>GCCCore</code> version. <code>CUDA</code> also has an associated <code>GCC</code> version, whcih needs to match the <code>CMAKE</code>-associated <code>GCCCore</code> version. We can check these versions by using <code>module spider</code> to inspect the available <code>CUDA</code> modules: <pre><code>[kelsieking23@inf092 infer]$ module spider CUDA\n----------------------------------------------------------------------------------------------------------------------\n  CUDA:\n----------------------------------------------------------------------------------------------------------------------\n    Description:\n      CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and\n      implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction\n      set and memory of the parallel computational elements in CUDA GPUs.\n\n     Versions:\n        CUDA/8.0.61\n        CUDA/9.0.176-GCC-6.4.0-2.28\n        CUDA/10.1.243-GCC-8.3.0\n        CUDA/10.1.243-iccifort-2019.5.281\n        CUDA/11.0.2-GCC-9.3.0\n        CUDA/11.0.2-iccifort-2020.1.217\n        CUDA/11.1.1-GCC-10.2.0\n        CUDA/11.1.1-iccifort-2020.4.304\n        CUDA/11.4.1\n        CUDA/11.7.0\n        CUDA/12.1.1\n        CUDA/12.3.2\n     Other possible modules matches:\n        CUDAcore  UCX-CUDA  chainer-py37-cuda10.1-gcc  chainer-py37-cuda10.2-gcc  cub-cuda10.1  cub-cuda10.2  cuda-dcgm  cuda10.1/blas  ...\n----------------------------------------------------------------------------------------------------------------------\n</code></pre> For this install, we will select <code>CMake/3.18.4-GCCcore-10.2.0</code> and <code>CUDA/11.1.1-GCC-10.2.0</code>. The minimum requirement for GROMACS 20204.4 is <code>CMake 3.18.4</code> or later, and <code>CUDA/11.1.1-GCC-10.2.0</code> has a matching <code>GCC</code> version available. </p> <p>Now, load the required modules:</p> <pre><code>[kelsieking23@inf092 infer]$ module reset\n[kelsieking23@inf092 infer]$ module load site/infer/easybuild/setup\n[kelsieking23@inf092 infer]$ module load CMake/3.18.4-GCCcore-10.2.0\n[kelsieking23@inf092 infer]$ module load CUDA/11.1.1-GCC-10.2.0\n[kelsieking23@inf092 infer]$ module load GCC/10.2.0\n</code></pre>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#gromacs-build","title":"GROMACS build","text":"<p>Earlier, we un-tarred <code>gromacs-2024.4.tar.gz</code>. The uncompressed folder, <code>gromacs-2024.4</code> should now be present in <code>/projects/bevanlab/software/infer</code>. Now, we need to create a folder for build files in <code>gromacs-2024.4</code> and move there: <pre><code>[kelsieking23@inf092 infer]$ cd /projects/bevanlab/software/infer/gromacs-2024.4\n[kelsieking23@inf092 gromacs-2024.4]$ mkdir build\n[kelsieking23@inf092 gromacs-2024.4]$ cd build\n</code></pre></p> <p>Create an initial build with <code>CMake</code>: <pre><code>[kelsieking23@inf092 build]$ cmake .. -DGMX_GPU=CUDA -DGMX_BUILD_OWN_FFTW=ON -DCMAKE_INSTALL_PREFIX=/projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4/\n</code></pre> Breaking down the command: * <code>..</code> : A positional argument. Indicates the  path to <code>CMake</code> set-up files relative to the current working directory (i.e. in the parent directory to <code>build</code>) * <code>-DGMX_GPU</code> : Toggles GROMACS installation with GPU support. <code>-DGMX_GPU=CUDA</code> enables CUDA support.  * <code>-DGMX_BUILD_OWN_FFTW</code> : <code>FFTW</code> is an important GROMACS dependency. <code>-DGMX_BUILD_OWN_FFTW=ON</code> toggles <code>CMake</code> to build a special <code>FFTW</code> library specifically for the GROMACS build, which is better for performance and software compatability.  * <code>-DCMAKE_INSTALL_PREFIX</code> : This specifies where to install GROMACS. The <code>setup_app</code> command from earlier instructed that the application be installed in <code>/projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4/</code>.</p> <p>For more information on <code>CMake</code> commands for building GROMACS, see the official GROMACS Installation Guide.</p> <p>Upon completion, we can start the build: <pre><code>[kelsieking23@inf092 build]$ make -j 12\n</code></pre> * <code>-j 12</code> : parallelizes the build process (12 threads) and is considerably faster. </p> <p>After the build completes, we can install the build: <pre><code>[kelsieking23@inf092 build]$ make install\n</code></pre></p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#modifying-module-files","title":"Modifying module files","text":"<p>The <code>setup_app</code> command created a <code>.lua</code> module file. In this file, we can specify module dependencies (i.e., CMake, CUDA, and GCC modules) that will be automatically loaded when the GROMACS installation is loaded. The file, <code>/projects/bevanlab/software/infer/modules/modules/infer-skylake/all/gromacs-v100/2024.4.lua</code>, was specified in the output of <code>setup_app</code> (see Setting up with <code>setup_app</code>). Open the file with <code>vi</code>: <pre><code>[kelsieking23@inf092 build]$ vi /projects/bevanlab/software/infer/modules/modules/infer-skylake/all/gromacs-v100/2024.4.lua\n</code></pre> The last line in the file stores information for dependencies. The default line should be:</p> <p><pre><code>load(\"foss/2020b\")\n</code></pre> Using the text-editor, we will change the line as follows: <pre><code>load(\"apps\",\"fosscuda/2020b\",\"GCC/10.2.0\", \"GCCcore/10.2.0\", \"CMake/3.18.4-GCCcore-10.2.0\", \"CUDA/11.1.1-GCC-10.2.0\")\n</code></pre></p>"},{"location":"ARC/Managing%20Shared%20Software/installing-gromacs-arc/#loading-and-testing-new-install","title":"Loading and testing new install","text":"<p>To check that the install functions correctly, reset all modules and load: <pre><code>[kelsieking23@inf092 infer]$ module reset\n[kelsieking23@inf092 infer]$ export MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\n[kelsieking23@inf092 infer]$ module load gromacs-v100/2024.4\n[kelsieking23@inf092 infer]$ gmx\n                         :-) GROMACS - gmx, 2024.4 (-:\n\nExecutable:   /projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4/bin/gmx\nData prefix:  /projects/bevanlab/software/infer/modules/apps/infer-skylake/gromacs-v100/2024.4\nWorking dir:  /projects/bevanlab/software/infer\nCommand line:\n  gmx\n\n...\n</code></pre></p>"},{"location":"Documentation%20Guide/configuring-pages/","title":"Configuring Documentation Pages","text":""},{"location":"Documentation%20Guide/configuring-pages/#file-name-convention","title":"File name convention","text":"<p>Keeping a naming pattern within files helps:</p> <ul> <li>stay consistent across the docs</li> <li>easily identify which software or tool is being described</li> </ul> <p>There is no specific file name convention. Our site organization keeps all related pages together in the same directory. Still, it should be relatively clear to other people what each file is or what topic it is associated with.</p> <p>Using a commonly used shorthand (e.g., gmx for GROMACS) as a prefix followed by the name of the technique or tool is the simplest way to organize files independent of the directories. For example, for a page on calculating solvent accessible surface area (SASA) in GROMACS, you could name this file <code>gmx-sasa.md</code>.</p>"},{"location":"Documentation%20Guide/configuring-pages/#updating-the-site-navigation","title":"Updating the site navigation","text":"<p>New pages are not automatically added to the site navigation. To view your new page in the documentation, they must be manually added to the <code>mkdocs.yml</code> file in the root directory of the GitHub repository.</p> <p>In <code>mkdocs.yml</code>, you will need to add the path to your page's MD file under the <code>nav</code> section. The <code>nav</code> section is a list, so make sure your new entry is spaced properly or the site will fail to compile. Paths used here are relative to the <code>docs/</code> directory.</p> <p>The general format is:</p> <pre><code>nav:\n  - Home: index.md\n  - Header 1:\n    - Header 1/index.md\n    - Section 1:\n      - Section 1 page: path/to/page.md\n      - Subsection 1:\n        - path/to/page.md\n    - Section 2:\n      - ...\n  - Header 2:\n  - ...\n</code></pre> <p></p> <p>The above navigation has a hierarchy of headers, sections, subsections, then pages. Sections can be nested as much as you want, but try to maintain only three levels to avoid over-complicating the nav.</p> <p>The highest level of the list will appear at the top of the site as a navigation tab. Clicking a navigation tab will bring you to the first file listed under that header.</p> <p>Pages can be listed two ways: titled with a path, or as a path only.</p> <pre><code>    - Subsection 1:\n      - Page: path/to/page.md\n      - path/to/page.md\n</code></pre> <p>Either format is acceptable. Titles not explicitly stated will be inferred from the first header of the page, which is helpful if you want to list the page differently than what is written in H1.</p> <p>Note</p> <p>If a section has subsections, paths cannot be written on the same line as the section title. Subsequent pages must be added in the next line, otherwise the site will fail to compile.</p>"},{"location":"Documentation%20Guide/configuring-pages/#additional-resources","title":"Additional Resources","text":"<ul> <li>MkDocs documentation on page configuration</li> </ul>"},{"location":"Documentation%20Guide/contribute/","title":"How to Contribute","text":"<p>The tools, technology, and approaches we use are always evolving, which means sometimes our documentation can become out of date or incomplete. If you would like to help update these pages, you will need the following:</p> <ul> <li>A GitHub account</li> <li>A code editor, such as Visual Studio Code</li> <li>Working knowledge of Markdown</li> </ul> <p>This site is built on Material for MkDocs, a Markdown-based documentation platform. All Markdown (and some HTML) is supported, but Material for MkDocs also provides additional Markdown features used in our documentation. We encourage you to check out their documentation for more information on these features.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/","title":"Using GitHub to Contribute","text":""},{"location":"Documentation%20Guide/git-contribution-guide/#introduction","title":"Introduction","text":"<p>Before getting started, make sure to reach out to Jonathan Briganti (jonbrig@vt.edu) to be added as a contributor to our GitHub repository.</p> <p>You will need:</p> <ul> <li>A GitHub account</li> <li>A terminal with Bash/Git Bash installed</li> <li>A code editor, such as Visual Studio Code</li> </ul> <p>Some code editors have GitHub integration that allow you to do a majority of the workflow through their user interface. Since this may differ between programs, this guide only walks through the command line workflow. For a webpage-based workflow, see the general GitHub guide.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#getting-started","title":"Getting Started","text":""},{"location":"Documentation%20Guide/git-contribution-guide/#cloning-the-repository","title":"Cloning the repository","text":"<p>You will need to clone the lab's GitHub repository before you can begin. Having a copy of the repository on your computer will make it easier to make and merge changes.</p> <p>GitHub provides a guide on how to clone a repository in their documentation.</p> <p>Note that remote and local repositories are different:</p> <ul> <li>The lab repository is the remote (or primary) repository whose contents are shown on these documentation webpages.</li> <li>The local repository is the copy of the lab's repository saved on your computer.</li> </ul> <p>Changes made locally will not affect the remote repository until they are pushed and approved.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#installing-mkdocs-optional","title":"Installing MkDocs (optional)","text":"<p>Installing Material for MkDocs locally is completely optional. However, if you plan to make multiple contributions to the documentation, a local installation is highly encouraged as it allows you to view your changes live before pushing changes to GitHub.</p> <p>Material for MkDocs and all dependencies (including MkDocs) can be installed using <code>pip</code> in a terminal:</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>A local installation allows us to use the <code>mkdocs serve</code> command, which opens a server to preview your changes. To preview changes, use <code>mkdocs serve</code> while in the same directory as the <code>mkdocs.yml</code> file. After the server initializes, there will be a link to the site preview in the terminal. The site will rebuild every time you save a file and can be closed using <code>Ctrl/Cmd+C</code> in the terminal.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#general-github-workflow","title":"General GitHub workflow","text":""},{"location":"Documentation%20Guide/git-contribution-guide/#making-changes-to-the-repository","title":"Making changes to the repository","text":""},{"location":"Documentation%20Guide/git-contribution-guide/#creating-and-working-on-branches","title":"Creating and working on branches","text":"<p>We advise you work on a separate branch to avoid accidentally overwriting existing files. A branch is a snapshot of the primary repository that you can edit independently of the main code base, allowing people to work on the same repository safely.</p> <p>Before creating a new branch, make sure your copy of the main branch is up to date. Updating your local copy before opening new branches will prevent merge conflicts down the line.</p> <pre><code>git switch main # switches branch to main\ngit pull origin main # pulls and synchronizes changes from remote repo\n</code></pre> <p>Then, create a new branch:</p> <pre><code>git switch -c &lt;branch name&gt; # creates new branch then switches to that branch\n</code></pre> <p>You can check which branch you are on, as well as see any other branches you may have, by entering <code>git branch</code> in your terminal. Your active branch is denoted by an <code>*</code>.</p> <p>From here, you are free to make your changes!</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#staging-and-committing-changes","title":"Staging and committing changes","text":"<p>As pages are finished, they need to be staged and committed before they can be merged into the primary repository.</p> <p>Staging serves as a record of files that are ready to be committed. Files that have been staged can be easily unstaged if you need to make additional changes. A real life analogy would be placing items into an online shopping cart.</p> <p>Committing updates the local repository with your changes. This would be similar to purchasing the items in that shopping cart.</p> <p>It is ideal to bundle similar changes into smaller commits, rather than one big commit, for easier code review. In some cases, this can also make it easier to troubleshoot merge conflicts.</p> <p>To view the current status of the staging area:</p> <pre><code>git status\n</code></pre> <p>This will print a summary of your current branch in the terminal, including staged, unstaged, and untracked changes. New files are considered untracked.</p> <p>While not necessary, it is advised to use <code>git status</code> between steps to make sure your commands are working as intended.</p> <p>You can add files to the staging area by:</p> <pre><code>git add . # adds all files in the current directory\n\ngit add &lt;file&gt; # add specific files only\n</code></pre> <p>Similarly, you can remove files from the staging area:</p> <pre><code>git restore --staged &lt;file&gt;\n</code></pre> <p>Once you are satisfied with your staged files, you can commit them:</p> <pre><code>git commit -m \"commit message\"\n</code></pre> <p>The commit message should briefly describe the contents of the commit. It should be easy for someone to figure out what changes you made or added.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#temporarily-stashing-changes","title":"Temporarily stashing changes","text":"<p>Alternatively, you may find that you need to switch branches for some reason, but your current branch is not ready to be committed. Attempting to switch branches with uncommitted changes will warn you to commit or stash them first.</p> <p>Stashing will temporarily save your changes locally and reverts the working directory to a clean state.</p> <pre><code>git stash # temporarily save tracked changes, cleans working directory\n\ngit stash push -m \"description of stash\" # expanded command + optional message\n</code></pre> <p>When you are ready to commit your changes, you can reinstate them:</p> <pre><code>git stash pop # restores latest stash and removes it from memory\n</code></pre> <p>This will bring the branch back into the pre-stashed state, or allows you to transfer changes to a different branch. You can confirm both of these commands work by using <code>git status</code>.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#pushing-changes","title":"Pushing changes","text":"<p>Commits do not automatically update the remote repository. They need to be pushed, reviewed, then merged before any changes appear on the website.</p> <p>To push your changes:</p> <pre><code>git push origin &lt;current branch&gt;\n</code></pre> <p>If you forget the name of your current branch, it is printed in the first line of the <code>git status</code> command.</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#creating-a-pull-request-pr","title":"Creating a pull request (PR)","text":"<p>Once you push your commit, you will need to create a pull request on GitHub. Navigate to the lab repository page and click Compare &amp; pull request in the header to open a pull request.</p> <p>Alternatively, navigate to Pull requests, then click New pull request. Click the drop-down box that says <code>compare: main</code>, then select your branch.</p> <p>On the next page, add a descriptive title and a bulleted description of changes you have made. You can view previous (closed) PRs for examples. Remember to assign Jon as a reviewer in the right-hand menu.</p> <p>After that, click Create pull request. You are done!</p>"},{"location":"Documentation%20Guide/git-contribution-guide/#summary-of-workflow","title":"Summary of workflow","text":""},{"location":"Documentation%20Guide/git-contribution-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub documentation</li> <li>Git documentation</li> </ul>"},{"location":"Documentation%20Guide/style-and-formatting/","title":"Style and Formatting","text":""},{"location":"Documentation%20Guide/style-and-formatting/#introduction","title":"Introduction","text":"<p>This documentation serves to host various guides on techniques and tools used in the lab, but is not in itself an academic article. As such, these pages do not necessarily follow a strict style. However, there are still some general guidelines contributors should follow in order to keep pages clear and consistent across writers.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#voice-and-tone","title":"Voice and tone","text":"<p>The voice and tone of these pages should be overall instructional but not clinical. Imagine you are working with and guiding someone through a process, or that you are giving a presentation to a class.</p> <p>Generally:</p> <ul> <li>make sure it's clear what you are referring to when using ambiguous terms like \"this\", \"it\", \"these\" - especially in articles about complex topics</li> <li>aim for a conversational tone, but avoid overly casual</li> <li>avoid language that assumes skill or knowledge (e.g., simply, naturally, clearly)</li> <li>avoid starting sentences the same way (\"to do X...\") or repetitive sentence structure</li> </ul> <p>Overall, prioritize readability and clarity. Section content does not need to be overly prosy, but also try to avoid sounding like you've written a recipe. Very long articles or user guides (like this page) may naturally end up prose-like, but you can be as concise as needed.</p> <p>The following resources have helpful guiding points if you need extra direction:</p> <ul> <li>The Voice and tone section of the GNOME developer documentation</li> <li>The Mozilla MDN documentation</li> <li>Creating effective technical documentation (Mozilla)</li> </ul> <p>Although we are not necessarily writing developer documentation, the advice in these guides are still generally applicable.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#general-formatting-guidelines","title":"General formatting guidelines","text":""},{"location":"Documentation%20Guide/style-and-formatting/#article-sections-and-organization","title":"Article sections and organization","text":"<p>Articles should begin with a brief introduction that summarizes the content. This does not need to be more than a few sentences. The introduction should include information important for understanding the technique or tool, at least on a practical level. It should also list any additional files or software needed to follow the guide.</p> <p>Some questions to help you get started:</p> <ul> <li>What are the key points of this guide?</li> <li>What does this tell us? Why do we care?</li> <li>If you were to write an FAQ on the topic, what would students ask you? Of these, what would the be most critical to know?</li> </ul> <p>The rest of the article should be split into logical sections, whether sequential or otherwise grouped. This will typically be a step-by-step format.</p> <p>While not required, it is helpful to add an \"Additional Resources\" section at the end of pages to include any external resources you think might be useful for understanding.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#section-and-subsection-titles","title":"Section and subsection titles","text":"<p>Titles displayed in the navigation should be in title case. Section and subsection titles within an article should be in sentence case.</p> <p>The point of each section should be obvious from the title so readers can jump around if they need to. Whenever possible, sections that are describing a process should be titled as an action (\"Updating the navigation\").</p>"},{"location":"Documentation%20Guide/style-and-formatting/#formatting-the-table-of-contents","title":"Formatting the table of contents","text":"<p>The table of contents will update automatically if the appropriate Markdown heading formatting is used. The top level heading (<code>H1</code>) will be used as the page's title in the navigation unless otherwise noted in the <code>mkdocs.yml</code> file. Sections should use level 2 (<code>H2</code>) headings and higher.</p> <pre><code># H1 - Page title\n## H2 - Section\n### H3 - Subsection\n#### H4 - Sub-subsection\n...\n</code></pre>"},{"location":"Documentation%20Guide/style-and-formatting/#section-content","title":"Section content","text":"<p>These guides will usually try to teach readers how to do something. Consider the following questions:</p> <ul> <li>Are there any tricky aspects of the technique or tool?</li> <li>What are some common issues, and how can they be avoided?</li> </ul> <p>A lot of confusion stems from readers not understanding what is functionally happening when they use a script or enter a command. Include examples (images, scenarios, etc.) if it would help with understanding. Split paragraphs into smaller sections to make them easier to digest, if needed. Remember, you don't need to explain every detail of a process, but it can be helpful to elaborate if readers are likely to hit roadblocks.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#text-styling-and-assets","title":"Text styling and assets","text":"<p>Text styling includes hyperlinking, code blocks, and other visual effects outside of the typical bold, italic, and underline. MkDocs has some quirks with special styles\u2014the most common of which are described below, along with general style recommendations. As always, visit the Material for MkDocs documentation for more information.</p> <p>All assets (images, scripts, etc.) should be saved into the appropriately named directory under <code>docs/assets/</code>. In most cases, the relevant directory will already exist. If it does not exist, be sure to make one.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#splitting-sections-with-horizontal-breaks","title":"Splitting sections with horizontal breaks","text":"<p>Sometimes sections contain a lot of information that cannot easily be split into subsections, causing confusing visual clutter. You can use horizontal breaks (---) to visually isolate content:</p> <pre><code>Words words words\n\n---\n\nWords words words\n</code></pre> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Words words words</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Words words words</p> <p>There must be an empty line before and after the dashes to render a horizontal break, otherwise Markdown will treat the preceding text like a <code>H2</code> heading.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#styling-code-blocks-and-in-line-code","title":"Styling code blocks and in-line code","text":"<p>You can create a code block by wrapping text with two lines of three backticks (```). Metadata such as line numbers, syntax highlighting, and titles are included immediately after the first set of backticks. Some common language codes for syntax highlighting are <code>python/py</code>, <code>bash/sh</code>, <code>r</code>, and <code>markdown/md</code>.</p> <pre><code>```python title=\"Titled code block\" linenums=\"1 (or other line # to start)\"\nimport matplotlib.pyplot as plt\nimport pandas as pd\n```\n</code></pre> Titled codeblock<pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\n</code></pre> <p>Line numbers, syntax highlighting, and titles are optional and can be omitted. </p> <p>Note</p> <p>Unfortunately, any single line of code that is too long will require scrolling to view the entire code block. This is a limitation of Markdown. Keep this in mind for especially long commands requiring multiple inputs or outputs!</p> <p>Long or whole scripts are handled differently and should not be in a code block.</p> <p>In-line snippets of code can be styled by surrounding the text with a single backtick (`). These are useful when talking about command or menu options.</p> <pre><code>This is `code`.\n</code></pre> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0This is <code>code</code>.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#software-specific-or-command-line-code","title":"Software-specific or command line code","text":"<p>When writing commands that involve inputs or outputs that will differ between projects, try to use a standard name or suggest a naming convention for clarity.</p> Instead of: Try: <code>gmx rmsf -f AbCeeD_replicate3_mol.xtc</code> <code>gmx rmsf -f trajectory.xtc</code> <p>Some software, such as GROMACS, and command lines use code that have additional options (e.g., <code>-help</code>). These are typically not required but may sometimes be useful.</p> <p>You can include these options below the code block using MkDocs admonitions:</p> <pre><code>???+ tip \"Title of the admonition\"\n\n    * `First option`: description of option\n    * ...\n</code></pre> Title of the admonition <ul> <li><code>First option</code>: short description of option</li> <li>...</li> </ul> <p>This specific admonition type is expandable and automatically opened on page load-in, giving readers the option to close and ignore them if needed.</p> <p>If options need to be explained, include a short blurb below the code block or admonition. One example of this can be seen in the GROMACS RMS guide.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#commands-that-produce-outputs","title":"Commands that produce outputs","text":"<p>Similar to above, if a command produces file outputs, try to directly list and describe each if more than one is expected:</p> <p>This produces the following outputs:</p> <ul> <li><code>-option</code>: short description of output</li> </ul> <p>The short description can be pulled directly from the relevant documentation pages. This is especially helpful for commands with ambiguously named output options, and isn't necessary for commands with one output.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#linking-to-pages","title":"Linking to pages","text":"<p>Links use basic Markdown formatting and can be used in most special MkDocs formatting, including admonitions and annotations. Links should be integrated into the text as much as possible.</p> <p>The general format for a link is:</p> <pre><code>[Text to be hyperlinked](link)\n</code></pre> <p>Try to avoid standalone or \"link\" links:</p> <p><pre><code>https://veryreallink.towebpage.com/\n\nYou can find the script here: [link](link to script)\n</code></pre> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0https://veryreallink.towebpage.com/</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0You can find the script here: link</p> <p>When in doubt, or in the absence of appropriate text, format links like:</p> <p><pre><code>You can find the script [here](link to script).\n</code></pre> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0You can find the script here.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#adding-images-and-videos","title":"Adding images and videos","text":"<p>While image embedding is natively supported, video embeds are not. If you want to include a video, you may need to link the file directly using link formatting, or save the video to our repository and redirect to the relevant directory.</p> <p>Images can be embedded in two ways, depending on whether you want to include a caption, set its page alignment, or adjust its size.</p> <p>The first way only uses Markdown:</p> <pre><code>![Image title](path or link to image){ align=left/right }\n</code></pre> <p>The image title functions as alt text and is only displayed if the image cannot be loaded. Image titles should be descriptive but brief, especially if no caption is added.</p> <p>The alignment attribute is optional and can be omitted. Images are left-aligned by default. Note that Markdown's <code>align</code> attribute does not support center alignment.</p> <p>The second way can be used to center align or add a caption. This method wraps additional HTML tags around the Markdown:</p> <pre><code>&lt;figure markdown=\"span\"&gt;\n  ![Image title](path or link to image){ width=\"integer or percentage\" }\n  &lt;figcaption&gt;Image caption.&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre> <p>This allows us to add image captions and dictate image size. By default, images embedded this way are center aligned. Both resizing and adding captions are optional and can be omitted. Since image captions are optional, we can also use this method to bypass the <code>align</code> limitations.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#adding-code-and-scripts","title":"Adding code and scripts","text":"<p>For now, scripts and interactive Jupyter Notebooks are kept in the appropriate <code>assets/</code> folder. These can be linked to directly using basic link formatting, or redirect readers to the relevant directory in the GitHub repository. Direct links to scripts will bring up a save prompt when clicked.</p> <p>Note that these are not the same as code blocks.</p>"},{"location":"Documentation%20Guide/style-and-formatting/#additional-resources","title":"Additional Resources","text":"<ul> <li>Material for MkDocs documentation</li> <li>Creating effective technical documentation (Mozilla)</li> </ul>"},{"location":"Lab%20Protocols/github-guide/","title":"Managing your files with GitHub","text":""},{"location":"Lab%20Protocols/github-guide/#introduction","title":"Introduction","text":"<p>Git is a version control software that helps us to maintain multiple versions of files and projects simultaneously. You can use Git to record changes to your project as you work on them, providing a convenient way to track your progress.</p> <p>GitHub is a platform built on Git that allows collaboration and sharing of your projects. While you can use Git through the command line, GitHub provides a convenient user interface, so you can maintain your projects easily through a webpage.</p> <p>You will need to create an account to use GitHub, which can be done through the link above.</p>"},{"location":"Lab%20Protocols/github-guide/#introduction-to-github","title":"Introduction to GitHub","text":"<p>To get started, we recommend completing this brief introductory course offered by GitHub. This course will guide you through setting up your first repository and performing your first commit and merge. It should take less than one hour to complete.</p> <p>The below guide walks you through some of the features briefly introduced in the introductory course.</p>"},{"location":"Lab%20Protocols/github-guide/#creating-your-repository","title":"Creating your repository","text":"<p>A repository (or \"repo\") is where all of your files are stored and maintained. You can create a new repo by clicking the + button at the top right of the main GitHub page, or the New button in the left-hand sidebar:</p> + buttonNew button <p> </p> <p> </p> <p>This will redirect you to a new page to create a new repository. Choose a descriptive repository name and provide a brief description, then set the repo's privacy (public or private). If you plan to add a longer description (such as project information), make sure Add a README file is also selected.</p> <p>When you are ready, click Create repository to generate the new repository. You should see a page similar to this:</p> <p>Welcome to your repository! There are a number of buttons at the top of your main repository page that you can explore. The following sections review the pages you will likely become most familiar with as you work with GitHub.</p>"},{"location":"Lab%20Protocols/github-guide/#navigating-your-repository","title":"Navigating your repository","text":""},{"location":"Lab%20Protocols/github-guide/#adding-your-files","title":"Adding your files","text":"<p>You can add files to your repository by clicking Add file, next to the &lt;&gt; Code button. In the drop-down, either choose Create new file or Upload files.</p> <p>Selecting Create new file will redirect to a page where you can create a file directly in GitHub:</p> <p>To create your file, give it a name and file extension (.py, .md, etc.), then type the contents into the text box. You can preview the page with the Preview tab, which is helpful if your file type can render special styling, like bold or italics.</p> <p>You can also Upload files, which will allow you to select files from your computer:</p> <p>Uploading a file that shares a name with an existing file will override that file in the repository. You can navigate to that file and view its change history by clicking History at the right-hand side. Selecting a commit (see Committing your files) will show you any changes made to that file, providing a way to track progress as you work on your projects.</p>"},{"location":"Lab%20Protocols/github-guide/#committing-your-files","title":"Committing your files","text":"<p>Regardless of which method you choose, both pages have a section to Commit changes. A commit allows you to save your files or changes to the repository. Commits function as a way to record changes to files, which you can reference later.</p> Create new fileUpload file <p> </p> <p> </p> <p>The first text box is the commit message. When committing changes, it is important to give it a descriptive message so you can easily figure out what each commit contains. You can optionally add a longer description in the second text box to expand on your commit message, though this should also remain relatively short (~1 sentence).</p> <p>Finally, you can commit directly into the <code>main</code> branch, which will save your files directly to the repository. Alternatively, you can create a new branch and generate a pull request (see Using branches to manage your work).</p>"},{"location":"Lab%20Protocols/github-guide/#using-branches-to-manage-your-work","title":"Using branches to manage your work","text":"<p>If you are working on an evolving project, like a series of scripts, it is best to work on a branch. Branches are snapshots of your main repository that can be edited independently from the primary code base. In shared repositories, branches allow multiple people can safely work on the same repository simultaneously without overwriting others' work. For a solo repository, branches can be helpful for working on different aspects of your projects at once. By default, your default branch will be <code>main</code>.</p> <p>To navigate between branches, click the drop-down menu with the branch icon () on the main page of your repository. You can create a new branch through the text box at the top of this menu.</p> <p>Clicking on Branches will take you to the branch overview. Here, you can manage (delete, rename, or view) the branches of the repository. You can also create a new branch.</p>"},{"location":"Lab%20Protocols/github-guide/#creating-pull-requests","title":"Creating pull requests","text":"<p>Pull requests (PRs) are generally used more often in collaborative repositories, and you will likely not use PRs in a solo repository. PRs allow you to have your code reviewed and receive feedback before merging changes into the primary branch. It also makes it easier to see the changes you made, all on one page.</p> <p>Navigate to Pull requests, then click New pull request. Click the drop-down box that says <code>compare: main</code>, then select your branch.</p> <p>On the next page, add a descriptive title and a bulleted description of changes you have made. Assign any reviewers, if your group has any.</p> <p>After that, click Create pull request. You are done!</p>"},{"location":"Lab%20Protocols/lab-scripts/","title":"Scripts by Members of BEL","text":""},{"location":"Lab%20Protocols/lab-scripts/#introduction","title":"Introduction","text":"<p>This page will slowly build over time to include links to GitHub repositories of useful scripts, code, and workflows. These may be useful in your research!</p>"},{"location":"Lab%20Protocols/lab-scripts/#fingerprinting-by-marion-lopresti","title":"Fingerprinting by Marion LoPresti","text":"<p>Link to Repository </p> <p>Visualizing the csv output from Schrodinger interaction fingerprints as a heatmap (multiple ligands) or bar graph (single ligand).</p>"},{"location":"Molecular%20Dynamics/","title":"Molecular Dynamics Homepage","text":""},{"location":"Molecular%20Dynamics/GROMACS/","title":"GROMACS Homepage","text":"<p>GROMACS is an open-source software package used to simulate the dynamics of lipids, nucleic acids, and proteins. It is capable of using a variety of forcefields\u2014AMBER, CHARMM, OPLS, GROMOS\u2014and is one of fastest MD packages for biomolecules. You can use GROMACS via the Advanced Research Computing clusters here at Virginia Tech.</p> <p>The following pages are guides for some of the GROMACS functions used the most often in this lab. Each provides an overview of the purpose of each command, what outputs you could expect, and how to generally use each command. While each guide may have a particular scenario in mind, all commands can likely be adapted to your systems as needed.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/","title":"Clustering Analysis","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/#introduction","title":"Introduction","text":"<p>Cluster analysis is used to identify dominant morphologies, or protein conformations, during the duration of an MD simulation. The <code>gmx cluster</code> command allows us to reduce trajectories into a few representative structures by clustering, or grouping, conformations that are structurally similar based on a given RMSD cut-off.</p> <p>You should have the following files:</p> <ul> <li>Trajectory file (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index file (.ndx) - OPTIONAL</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/#using-gmx-cluster","title":"Using <code>gmx cluster</code>","text":"<p>This command generates multiple outputs, so it is advisable to create a new directory to store these files.</p> <p>To use perform clustering analysis:</p> <pre><code>gmx cluster -f trajectory.xtc -s topology.tpr -n index.ndx -method gromos -cutoff 0.2 -o rep_clust.xpm -g rep_clust.log -cl rep_clust.pdb -sz rep_size.xvg\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-tu</code>: time units (default is ps, ns is recommended)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> </ul> <p>The <code>-method</code> option specifies the clustering algorithm, typically the <code>gromos</code> algorithm. The <code>-cutoff</code> option indicates the RMSD boundary (in nm) for structures to be considered similar enough to be clustered.</p> <p>Clustering should be performed after your system achieves convergence(1), so you will need to supply a starting time using <code>-b</code>. The duration that you are analyzing is considered your sampling period.</p> <ol> <li>See Root Mean Square Deviation and Fluctuation</li> </ol> <p>Running the command will prompt you to select two groups. Select <code>Backbone</code> for least squares fit and RMSD. When prompted to select an output group, select the group that includes everything you intend to visualize. This will often be just the protein (<code>Protein</code>), but you may also want to include any additional molecules (e.g., ligands), depending on your simulation. Note that more complex outputs will require a custom index file.</p> <p>This produces the following outputs:</p> <ul> <li><code>-o</code>: RMSD matrix</li> <li><code>-g</code>: information on clusters and the frames in those clusters</li> <li><code>-sz</code>: distribution of cluster size</li> <li><code>-cl</code>: PDB file of representative structures from each cluster</li> </ul> <p>Detailed information on the clustering, such as average RMSD and specific frame sorting, can be found in the LOG file generated by <code>-g</code>. The PDB file contains representative structures for each cluster identified and is used for PyMOL visualizations.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/#identifying-dominant-morphologies","title":"Identifying dominant morphologies","text":"<p>The size distribution generated by <code>-sz</code> helps us determine which protein conformations are the most common across the sampling period. Similar to the LOG file, this file lists all clusters identified by the <code>gmx cluster</code> command, as well as the number of frames contained in that cluster. Note that the first cluster will always have the most frames.</p> Cluster size distribution of one simulation. <p>In our example, we see that 5 clusters were identified. Cluster 1 contains 326 frames out of 501, which seems like a significant portion of the sampling period.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/#calculating-cluster-occupancy","title":"Calculating cluster occupancy","text":"<p>Cluster occupancy is a quantitative measure of how often a cluster's conformation occurs during the sampling period. At minimum, the threshold is 50% occupancy for a cluster to be dominant. If your first cluster has less than 50% occupancy, you may need to increase your <code>-cutoff</code> value and rerun the command.</p> <p>To calculate occupancy of a cluster, divide the total number of frames by the number of frames in the first cluster, then multiply by 100.</p> <p>Returning to the previous example, 326 frames of 501 occupies approximately 65.1% of the sampling period, which is above the 50% threshold.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-cluster/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx cluster</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dist/","title":"Measuring Distances","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-dist/#introduction","title":"Introduction","text":"<p>GROMACS has a few commands that can calculate the distance between atoms or groups of atoms:</p> <p><code>gmx distance</code> calculates distances between fixed pairs of atoms. This is useful if you are interested in specific residues involved in processes, like protein-ligand interactions.</p> <p><code>gmx mindist</code> calculates the minimum distance and number of contacts between pairs of atoms.</p> <p>Note</p> <p>You will need to use a custom index file if you are measuring distance between custom groups of atoms.</p> <p>You should have the following files for both commands:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index file (.ndx)</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dist/#using-gmx-distance","title":"Using <code>gmx distance</code>","text":"<p>To calculate distances between fixed pairs:</p> <pre><code>gmx distance -f trajectory.xtc -s topology.tpr -n index.ndx -tu ns -select 'first group' 'second group' '...' -oav avg-dist.xvg -oxyz comp-dist.xvg\n</code></pre> <p><code>-select</code> allows you to directly indicate which groups you want to analyze, which is convenient for slurm scripts. If the <code>-select</code> option is not used, you will be presented with a group selection menu after running the command.</p> <p>Note that <code>gmx distance</code> can take more complex selections than what is typical of standard index files. Enter <code>help examples</code> in the prompt for examples.</p> <p>This produces the following outputs:</p> <ul> <li><code>-oav</code>: average distances as a function of time</li> <li><code>-oxyz</code>: distance components (x-/y-/z-axis) as a function of time</li> <li>These XVG files can be visualized using Python or Grace to produce a plots of distance versus time, or to generate a heat-map.</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dist/#using-gmx-mindist","title":"Using <code>gmx mindist</code>","text":"<p>To calculate the minimum distance between pairs:</p> <pre><code>gmx mindist -f trajectory.xtc -s topology.tpr -n index.ndx -d &lt;nr&gt; -tu ns -od mindist.xvg -on count.xvg -or mindist-res.xvg -group\n</code></pre> <p><code>-group</code> tells GROMACS that all contacts between one atom in a group and multiple atoms of the other group should be considered a single contact. <code>-d</code> specifies the distance cut-off in angstroms for a pair to be considered in contact.</p> <p>You will then be prompted to select two groups to measure distances between.</p> <p>This produces the following outputs:</p> <ul> <li><code>-od</code>: minimum distances between pairs of atoms</li> <li><code>-on</code>: number of contacts between pairs of atoms</li> <li><code>-or</code>: minimum distances to residues in group 1, plotted as a function of residue number</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dist/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx distance</li> <li>gmx mindist</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dssp/","title":"Determining Secondary Structure (DSSP)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-dssp/#introduction","title":"Introduction","text":"<p><code>gmx do_dssp</code> determines a protein's secondary structure based on hydrogen bonding patterns between residues. DSSP is able to determine the formation of/changes in  helices, sheets, and disordered regions (coils). This allows us to study how a protein's conformation may morph and move throughout the span of a simulation.</p> <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Structure or topology file (.gro/.tpr)</li> <li>Index file (.ndx)</li> </ul> <p>Note</p> <p><code>gmx do_dssp</code> was changed to <code>gmx dssp</code> in the 2023 version of GROMACS. This page references the older <code>do_dssp</code> command.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dssp/#using-gmx-do_dssp","title":"Using <code>gmx do_dssp</code>","text":"<p>To determine the secondary structure of your proteins:</p> <pre><code>gmx do_dssp -f trajectory.xtc -s structure.gro -n index.ndx -tu ns -o ss.xpm -sc sscount.xvg\n</code></pre> <p>GRO and TPR files may be used interchangeably for the <code>-s</code> option. If you are trying to determine the secondary structure of a multi-subunit protein with identical chains (homo-oligomers), you may need to create a custom GRO file to properly run this command.</p> <p><code>gmx do_dssp</code> produces the following outputs:</p> <ul> <li><code>-o</code>: structure assignment as a function of time</li> <li><code>-sc</code>: structure count as a function of time</li> </ul> <p>Both the XPM (<code>-o</code>) and XVG (<code>-sc</code>) files can be parsed using Python or Grace for visualization. XPM files can also be processed through <code>gmx xpm2ps</code>. This will transform the data into a labelled plot that may be opened through programs like GIMP.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dssp/#using-gmx-do_dssp-with-homo-oligomeric-proteins","title":"Using <code>gmx do_dssp</code> with homo-oligomeric proteins","text":"<p>Homo-oligomers have the same residue numbers designated across identical subunits. This creates issues with the DSSP algorithm, causing the command to stall at the first frame of the simulation. To get around this, you will need to create GRO and NDX files with each protein residue renumbered sequentially.</p> <p>If you do not have an original GRO file, you can generate one:</p> <pre><code>gmx trjconv -f trajectory.xtc -s topology.tpr -o structure.gro\n</code></pre> <p>To edit this GRO file and renumber the protein residues:</p> <pre><code>gmx editconf -f structure.gro -resnr 1 -o renumbered.gro\n</code></pre> <p><code>-resnr</code> indicates the residue number to start from, in this case 1.</p> <p>If you are analyzing specific parts of your protein, you will need to create a new NDX file using the renumbered GRO file:</p> <pre><code>gmx make_ndx -f renumbered.gro -o renumbered.ndx\n</code></pre> <p>If you are unsure of how to use this command to create special atom groups, refer to the guide on GROMACS index files.</p> <p>Both renumbered files can be used as an input for the <code>-s</code> option as described in the Using <code>gmx do_dssp</code> section.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-dssp/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx do_dssp</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-eccentricity/","title":"Measuring Eccentricity","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-eccentricity/#introduction","title":"Introduction","text":"<p>Eccentricity is a measure of how much a protein or complex's shape deviates from a sphere, or its roundness.</p> <p>Eccentricity (e) is calculated using the moments of inertia (I) from the three principal axes (x, y, z). Values of e closer to 0 are considered more spherical, while values closer to 1 are more ellipsoid.</p> <p>e can be calculated using the following equation<sup>1</sup>:</p> <p>I for each axis can be calculated using <code>gmx gyrate</code> with the <code>-moi</code> option. Note that <code>gmx principal</code> may also be used to determine I, but <code>gmx gyrate</code> is currently supported in scripts used by our lab.</p> <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> </ul> <p>Note</p> <p><code>gmx gyrate</code> was changed in the 2024 version of GROMACS. This page references the command as it was in prior releases.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-eccentricity/#using-gmx-gyrate","title":"Using <code>gmx gyrate</code>","text":"<p>To calculate moments of inertia using <code>gmx gyrate</code>:</p> <pre><code>gmx gyrate -f trajectory.xtc -s topology.tpr -o moi.xvg -moi\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> </ul> <p>Warning</p> <p>You MUST use the <code>-moi</code> option, otherwise GROMACS will calculate radius of gyration instead.</p> <p>When prompted, select the atom group you wish to analyze. Special groups will require a custom index file to be supplied with <code>-n</code>.</p> <p>This will output an XVG file of I versus time. This file can be processed to extract each value and calculate the eccentricity of your protein. Alternatively, it can also be visualized using Grace or Python, as is.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-eccentricity/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx gyrate</li> </ul> <ol> <li> <p>This is the equation used in the lab to determine e. Occasionally, you will find literature that also uses a more simplified equation of e = 1 - (I<sub>min</sub>/I<sub>avg</sub>).\u00a0\u21a9</p> </li> </ol>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gangle/","title":"Measuring Angles","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-gangle/#introduction","title":"Introduction","text":"<p><code>gmx gangle</code> can be used to calculate the angles between groups of vectors. Specifically, <code>gmx gangle</code> can compute angles between a vector or plane and another vector, plane, the z-axis, or the normal vector of a sphere. It can also compute angles and dihedrals, similar to <code>gmx angle</code>.</p> <p>Like the <code>gmx distance</code> command, this command allows us to study movement of features, like protein hinges.</p> <p>Note</p> <p>You will need to use a custom index file if you are measuring angles between custom groups of atoms.</p> <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index file (.ndx)</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gangle/#using-gmx-gangle","title":"Using <code>gmx gangle</code>","text":"<p>To calculate angles:</p> <pre><code>gmx gangle -f trajectory.xtc -s topology.tpr -n index.ndx -tu ns -oav all-angles.xvg -oall all-angles.xvg  -oh angle-hist.xvg -g1 vector -group1 &lt;group&gt; -g2 vector -group2 &lt;group&gt; \n</code></pre> <p><code>-g1</code> and <code>-g2</code> indicate the type of angle that should be analyzed (<code>vector</code>, <code>plane</code>, <code>angle</code>, or <code>dihedral</code>). These options are closely tied to the <code>-group1</code> and <code>-group2</code> options, which specify the atom positions to be analyzed. The groups to be analyzed are taken from the index file supplied with <code>-n</code>.</p> <p>As the inputs for these options are highly dependent on the system, refer to the <code>gmx gangle</code> documentation page for valid <code>-g1/g2</code> and <code>-group1/group2</code> combinations.</p> <p>This produces the following outputs:</p> <ul> <li><code>-oav</code>: average angles as a function of time</li> <li><code>-oall</code>: all angles as a function of time</li> <li><code>-oh</code>: histogram of angles</li> </ul> <p>These XVG files can be visualized using Python or Grace to produce a plots of angle versus time, or to generate a heat-map from histogram data.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gangle/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx gangle</li> <li>Bonds/distances, angles and dihedrals (GROMACS reference manual)</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gyrate/","title":"Radius of Gyration (R<sub>g</sub>)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-gyrate/#introduction","title":"Introduction","text":"<p>Radius of Gyration (R<sub>g</sub>) is a measure of protein size and compactness across the duration of the simulation. Fluctuations in R<sub>g</sub> can also indicate protein flexibility and stability, where dramatic increases in R<sub>g</sub> may suggest unfolding or expansion. R<sub>g</sub> can be calculated using <code>gmx gyrate</code> and is generally reported as nanometers (nm) plotted against time.</p> R<sub>g</sub> graph from one set of simulations. R<sub>g</sub> is plotted as nanometer (nm) versus time (ns). <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> </ul> <p>Note</p> <p><code>gmx gyrate</code> was changed in the 2024 version of GROMACS. This page references the command as it was in prior releases.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gyrate/#using-gmx-gyrate","title":"Using <code>gmx gyrate</code>","text":"<p>To calculate radius of gyration:</p> <pre><code>gmx gyrate -f trajectory.xtc -s topology.tpr -o gyrate.xvg\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> </ul> <p>When prompted, select the group you want to analyze. This will likely be <code>Backbone</code> or another special group, like for individual chains. Note that special groups will require a custom index file to be supplied with <code>-n</code>.</p> <p>This will output an XVG file of R<sub>g</sub> versus time that can be visualized using Grace or Python.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-gyrate/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx gyrate</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-hbond/","title":"Hydrogen Bonds (H-bond)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-hbond/#introduction","title":"Introduction","text":"<p><code>gmx hbond</code> allows us to determine the number and angle of hydrogen bonds between groups of H-bond acceptors and donors.</p> <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index file (.ndx)</li> </ul> <p>Note</p> <p><code>gmx hbond</code> was changed in the 2024 version of GROMACS. This page references the command as it was in prior releases.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-hbond/#using-gmx-hbond","title":"Using <code>gmx hbond</code>","text":"<p>To calculate H-bond properties:</p> <pre><code>gmx hbond -f trajectory.xtc -s topology.tpr -n index.ndx -tu ns -num hbnum.xvg -g hbond.log\n</code></pre> Other options you may find useful <ul> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> <li><code>-r</code>: the distance cutoff for H-bonds</li> <li><code>-dist</code>: outputs the distance distribution of all H-bonds</li> <li><code>-ang</code>: outputs the angle distribution of all H-bonds</li> </ul> <p>You will be prompted to select two groups. Select the groups you want to analyze. Note that special groups will require a custom index file to be supplied with <code>-n</code>.</p> <p>This produces the following outputs:</p> <ul> <li><code>-num</code>: number of H-bonds as a function of time</li> <li><code>-g</code>: information on H-bond acceptor-donor pairs</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-hbond/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx hbond</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/","title":"Creating Index Files","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/#introduction","title":"Introduction","text":"<p>Sometimes we are interested in only analyzing specific parts of a protein in a simulation. GROMACS index files (NDX) contain information on atom groups such as protein-associated atoms, ions, and other molecules (e.g., ATP or ADP). Index files are used with the <code>-n</code> option in various GROMACS modules to analyze portions of your protein.</p> <p>By default, GROMACS will use a preset of groups if no index file is supplied.</p> <p>We can make custom index files for special groups through the <code>gmx make_ndx</code> command.</p> <p>You should have the following files:</p> <ul> <li>Topology file (.tpr)</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/#using-gmx-make_ndx","title":"Using <code>gmx make_ndx</code>","text":"<p>To create an index file:</p> <pre><code>gmx make_ndx -f topology.tpr -o output.ndx\n</code></pre> <p>You can additionally supply a pre-existing index file to modify using the <code>-n</code> option.</p> <p>In either case, you will be presented with the index editor containing default atom groups, grouping options, and a prompt to enter commands (<code>&gt;</code>).</p> <p></p> <p>Entering <code>q</code> at this point will save a NDX file containing only default groups.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/#navigating-the-index-editor","title":"Navigating the index editor","text":"<p>To create special groups, we will need to use the grouping options. Type <code>h</code> to show the help menu.</p> <p></p> <p>The help menu explains how to use each grouping option. It also provides a few examples at the bottom showing how to use multiple options with operators (<code>! &amp; |</code>).</p> <p>Hitting <code>ENTER</code> with an empty command prompt will repopulate the group list and bring you to the original menu.</p> <p>Generally, you will not need to do overly complicated index file manipulation.</p> <p>To select a range of atoms, like the first 100:</p> <pre><code>a 1-100\n</code></pre> <p>Similarly, for the first 100 residues:</p> <pre><code>r 1-100\n</code></pre> <p>You can also mash commands together using operators (<code>! &amp; |</code>).</p> <p>To select the backbone and side-chain hydrogen atoms of residues 300 to 350, but not residue 325:</p> <pre><code>4 | 9 &amp; r 300-350 &amp; ! r 325\n</code></pre> <p>Breaking this command down:</p> <ul> <li><code>4 | 9</code> selects all atoms that are part of either groups 4 OR (<code>|</code>) 9.<ul> <li>Using AND (<code>&amp;</code>) here will return an empty group, as <code>&amp;</code> looks for atoms shared by both groups.</li> </ul> </li> <li><code>&amp; r 300-350  &amp; ! r 325</code> selects residues 300 to 350 and NOT (<code>&amp; !</code>) residue 325.</li> </ul> <p>Note that if your protein has multiple chains, <code>r &lt;residue number&gt;</code> will select all residues with that number. To select residues in specific chains only, you will need to create chain-only groups first.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/#splitting-protein-chains","title":"Splitting protein chains","text":"<p>A common way of using <code>gmx make_ndx</code> is to create special groups for protein chains. The <code>splitch &lt;group number&gt;</code> option splits the protein into chains that contain only atoms from the specified group.</p> <p>In the group list above, the entire protein is defined in Group 1 and the backbone is defined in Group 4.</p> <p><code>splitch 1</code> will create individual groups for each protein chain. These groups will contain all atoms of that chain, including those in side-chains.</p> <p><code>splitch 4</code> will also create individual groups per chain, but these groups will only contain the atoms of the protein backbone.</p> <p>This particular protein has six chains. After repopulating the group list with <code>ENTER</code>, we see both grouping options created six groups each, with <code>splitch 1</code> groups boxed in red (21 to 26) and <code>splitch 4</code> boxed in yellow (27 to 32).</p> <p>Note</p> <p>Splitting actions like <code>splitch</code>, <code>splitat</code>, and <code>splitres</code> cannot be used with other options or operators. Instead, these must be executed sequentially.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-ndx/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx make_ndx</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/","title":"Principal Component Analysis (PCA)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#introduction","title":"Introduction","text":"<p>Principal component analysis (PCA) allows us to identify major changes in conformation and movement after MD simulation.</p> <p>This guide assumes you have all files in the same directory. If not, be sure to reference each file from their respective directories \u2013 though it will be much easier later if all files are in the same directory.</p> <p>Small systems will be able to do the initial set-up, <code>gmx covar</code>, and <code>gmx anaeig</code> within the same interactive session. If you have very large/complex systems you wish to compare, you may need to submit a slurm job to run these commands.</p> <p>Interactive sessions allow us to use an allocation of ARC to actively submit commands, rather than queueing a job and waiting.</p> <p>To begin an interactive session of 2 hours:</p> <pre><code>interact -p v100_dev_q -A bevanlab --gres=gpu:1 --nodes=1 --ntasks-per-node=12 -t 2:00:00\n</code></pre> <p>Then import the necessary modules (copy and paste individual lines to the command line):</p> <pre><code>module load apps site/infer/easybuild/setup\nmodule load CMake/3.15.3-GCCcore-8.3.0\nmodule load CUDA/10.1.243-GCC-8.3.0\n\nexport MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\nmodule load gromacs-v100/2020.4\n</code></pre>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#initial-set-up","title":"Initial set-up","text":"<p>You should have the following files from your MD simulations:</p> <ul> <li>Final trajectory files (.xtc) for all replicates</li> <li>Topology file (.tpr) from any replicate</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#concatenate-trajectory-files","title":"Concatenate trajectory files","text":"<p>All trajectory (.xtc) replicates must be concatenated, or joined together, in order to analyze the average motion of your system.</p> <p>Note</p> <p>You MUST use the <code>-cat</code> option, otherwise duplicate timeframes will be overwritten by the last XTC file used.</p> <pre><code>gmx trjcat -f rep1.xtc rep2.xtc rep3.xtc -cat -o all_cat.xtc\n</code></pre>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#get-backbone-only-trajectory-xtc","title":"Get backbone-only trajectory (.xtc)","text":"<p>Since covariance analysis is performed on the protein backbone, you will need to generate an xtc trajectory file containing the protein backbone only.</p> <p>To generate a backbone-only XTC file: <pre><code>gmx trjconv -s topology.tpr -f all_cat.xtc -o all_cat_backbone.xtc\n</code></pre></p> <p>Select backbone when prompted.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#get-backbone-only-topology-file-tpr","title":"Get backbone-only topology file (.tpr)","text":"<p>The topology (.tpr) and trajectory (.xtc) files MUST match in atom count, otherwise you will get a fatal error when trying to run <code>gmx covar</code>.</p> <p>To guarantee a match, create a backbone-only TPR file: <pre><code>gmx convert-tpr -s topology.tpr -o backbone.tpr\n</code></pre></p> <p>Select backbone when prompted. It does not matter which TPR file is used (whether replicate 1 or 3), as <code>gmx covar</code> will only be referencing the structural information.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#covariance-analysis","title":"Covariance analysis","text":"<p>You need the new concatenated backbone-only XTC and TPR files generated in the initial set-up to perform covariance analysis. Because this step generates many files, it is advisable to make a new directory (e.g., <code>covar/</code>) to store your outputs.</p> <p>To perform covariance analysis:</p> <pre><code>gmx covar -f all_cat_backbone.xtc -s backbone.tpr -o ./covar/eigenval.xvg -ascii ./covar/ascii.dat -av ./covar/ave.pdb -v ./covar/eigenvec.trr\n</code></pre> <p>Select backbone when prompted.</p> <p>This produces the following outputs:</p> <ul> <li><code>-o</code>: eigenvalues of the covariance matrix</li> <li><code>-ascii</code>: the whole covariance matrix, in text form</li> <li><code>-av</code>: the average structure</li> <li><code>-v</code>: the full precision trajectory</li> </ul> <p>Repeat this for all systems. Be sure to use a clear naming convention, as this data will be projected onto each other in the next step.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#analysis-of-eigenvectors","title":"Analysis of eigenvectors","text":"<p>In order to analyze changes in motion during simulation, the outputs from the previous step must be processed using <code>gmx anaeig</code>.</p> <p>The following files are needed for every system you plan to compare:</p> <ul> <li><code>backbone.xtc</code></li> <li><code>eigenval.xvg</code></li> <li><code>ave.pdb</code></li> <li><code>eigenvect.trr</code></li> </ul> <p>To perform eigenvector analysis:</p> <pre><code># Project MUT onto WT\ngmx anaeig -s wt_ave.pdb -f mut_backbone.xtc -v wt_eigenvec.trr -eig wt_eigenval.xvg -proj mut_wt_proj-ev.xvg -extr mut_wt_ev.pdb -2d mut_wt_eigtraj.xvg \n\n# Project WT onto MUT\ngmx anaeig -s mut_ave.pdb -f wt_backbone.xtc -v mut_eigenvec.trr -eig mut_eigenval.xvg -proj wt_mut_proj-ev.xvg -extr wt_mut_ev.pdb -2d wt_mut_eigtraj.xvg\n</code></pre> <p>Select backbone, protein, or system when prompted (these are all the same).</p> <p>This produces the following outputs:</p> <ul> <li><code>-proj</code>: the projections of trajectories on the first and last eigenvectors</li> <li><code>-extr</code>: the two extreme projections along the average structure</li> <li><code>-2d</code>: 2D projection of trajectories on the eigenvectors</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#data-visualization-and-analysis","title":"Data visualization and analysis","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#graphing-2d-projections","title":"Graphing 2D projections","text":"<p>You will need the <code>mdpca.py</code> file to create PCA graphs from the 2D projection data. A version of this file is available here. You will also need a way to run Python 3 scripts.</p> <p>The following files are needed for every system you plan to compare:</p> <ul> <li><code>eigtraj.xvg</code></li> </ul> <p>All relevant files must be in the same directory as the script OR use a path to the file.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#using-mdpcapy","title":"Using <code>mdpca.py</code>","text":"<p>Open the script in a code editor and configure the following:</p> <ol> <li>Under <code>#2D INPUT FILES</code>, change file names to match the two <code>eigtraj.xvg</code> files.</li> <li>Under <code>#GRAPH COLORS</code>, change the hex codes to adjust graph colors.</li> <li>Under <code>#TITLE AND FILE PARAMETERS</code>, change the graph title and output file name.<ul> <li>The graph title can be styled using Mathtext or LaTeX.</li> <li>By default, graphs are saved as PNG files.</li> </ul> </li> </ol> <p>Save and run the script. The output will be two side-by-side projection graphs with a single title:</p> <p></p> <p>The degree of overlap between the two datasets represents how structurally similar the systems are during simulation. Overlap in the data suggests these simulations take on more similar structures, or sample similar conformational space. Conversely, regions without overlap indicate differences in conformation.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#visualizing-extreme-structures-with-pymol","title":"Visualizing extreme structures with PyMOL","text":"<p>The conformational changes indicated by the 2D graphs can be visualized by looking at the extreme structures that were generated by <code>-extr</code> of <code>gmx anaeig</code>. Opening one of these PDB files in PyMOL gives us a protein structure with two frames. Each frame represents the first and last eigenvectors, which are depicted in the 2D graph as the X- and Y-axes, respectively.</p> <p>If your 2D graphs show any regions without overlap, these two frames should be different when you toggle between them. We can add arrow indicators to show the degree and direction of these differences using <code>modevectors</code>.</p> <p>To do this, you will need the <code>modevectors.py</code> script. You can additionally use the optional <code>modesplit.py</code> script, which automates part of this process with a little extra set-up. Place all scripts in the same directory as the PDB files you are working with.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#using-modevectorspy","title":"Using <code>modevectors.py</code>","text":"<p>The <code>modevectors.py</code> script requires that the two frames be split into two PyMOL objects. This can be done through the graphical user interface (GUI) or the PyMOL command line.</p> GUICommand line <p>To do this in the PyMOL GUI, find the object buttons at the right of the program. Navigate to either your protein or the \"all\" object and click the A icon.</p> <p>Navigate to the \"state\" option, then select \"split\".  </p> <p>This will create 2 new objects, \"protein_0001\" and \"protein_0002\", which correspond to the two frames.</p> <p>To do this in the PyMOL command line, type <code>split_states all</code>.   This will create 2 new objects, \"protein_0001\" and \"protein_0002\", which correspond to the two frames.</p> <p>You can now use <code>modevectors.py</code>! Run each of the following lines individually in the PyMOL command line, replacing the object names as appropriate:</p> <pre><code>run modevectors.py\n\nmodevectors first_obj_frame, last_obj_frame, skip=0\n</code></pre> <p><code>skip</code> indicates how many vectors (arrows) are skipped during rendering. Adjust this if the final render is too visually cluttered.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#using-modesplitpy","title":"Using <code>modesplit.py</code>","text":"<p>Repeatedly running Modevectors can be tedious if you are analyzing multiple systems with the same protein, or multi-subunit systems where you want to analyze each subunit individually. The <code>modesplit.py</code> script is an additional (optional) script that can split subunits and automate the above process. It requires some set-up, but afterwards the script can be run as-is for all relevant PDB files.</p> <p>Open <code>modesplit.py</code> in a code editor. Define all protein subunits in the <code>#CHAINS</code> dictionary. The dictionary can be modified for any number of subunits, but at least one entry is required to run.</p> <p>Note that the <code>start_index</code> and <code>end_index</code> ask for the index of the first and last atoms of the subunit, not residues. This is to avoid duplicates with homo-oligomers, which will have the same residue numbers designated across identical subunits.</p> <p>To find the index of an atom in PyMOL:</p> <ol> <li>Select the first residue of the subunit. In the command line, type <code>index %sele</code> and hit enter. PyMOL will return three lines of text. Note the number at the end of the first line of the output.</li> <li>Click off the protein to deselect the residue.</li> <li>Repeat step 1, instead selecting the last residue of the subunit. Note the number at the end of the last line of the output.</li> <li>Repeat for all subunits.</li> </ol> Output of the index command. <p>Update the indices, then save the file. Load it into PyMOL using <code>run modesplit.py</code> in the command line.</p> <p>Note</p> <p>This script will also automatically run <code>modevectors.py</code>. You can adjust the parameters for Modevectors in line 47.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#analyzing-motion-with-direct-id","title":"Analyzing motion with DIRECT-ID","text":"<p>DIRECT-ID is a program that identifies residues with the greatest variance in movement between two systems based on the covariance matrices produced by <code>gmx covar</code>.</p> <p>The following files are needed to perform DIRECT-ID analysis:</p> <ul> <li><code>ascii.dat</code> for both systems of interest</li> <li><code>ave.pdb</code> for either system</li> </ul> <p>DIRECT-ID should already be set-up on ARC and can be accessed using the following command:</p> <pre><code>direct_id 3NXN wt_ascii.dat mut_ascii.dat wt_ave.pdb direct_id_output.txt\n</code></pre> <p>Depending on where you are trying to run the analysis, you may need to run the command using a path to the DIRECT-ID program.</p> <pre><code>(../)../../direct_id 3NXN wt_ascii.dat mut_ascii.dat wt_ave.pdb direct_id_output.txt\n</code></pre> <p>Regardless of how the program is run, two outputs will be generated: a text file containing a list of atoms with the most variance in movement, and a command line output listing the residues.</p> <p>In most cases, the terminal output is the most relevant. Record or screenshot this output, as it does not get saved in a file. The residues listed should match those with the greatest motion in the Modevectors analysis.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-pca/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx trjcat</li> <li>gmx trjconv</li> <li>gmx convert-tpr</li> <li>gmx covar</li> <li>gmx anaeig</li> <li>Modevectors</li> <li>DIRECT-ID</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-rms/","title":"Root Mean Square Deviation and Fluctuation (RMSD/RMSF)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-rms/#introduction","title":"Introduction","text":"<p>Root-mean-square deviation (RMSD) is a measure of how much a structure differs from a starting or reference structure, usually reported in angstroms (\u00c5) or nanometers (nm). In GROMACS, RMSD is calculated with <code>gmx rms</code>. </p> <p>Plotting RMSD against time tells us two things:</p> <ol> <li>How much the protein structure has changed since the start of the simulation. Greater RMSD values indicate greater change, and vice versa.</li> <li>Whether our simulation has achieved convergence, or a state of equilibrium.</li> </ol> RMSD graph from one set of simulations. RMSD is plotted as nanometer (nm) versus time (ns). <p>Similarly, root-mean-square fluctuation (RMSF) allows us to identify regions that are highly flexible throughout the simulation. RMSF is calculated using <code>gmx rmsf</code> and is plotted as a function of protein residue.</p> RMSF graph from the same simulations. RMSF is plotted as nanometer (nm) versus residue number. <p>You should have the following files for RMSD/RMSF:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> <li>Index files (.ndx) - OPTIONAL</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-rms/#using-gmx-rms","title":"Using <code>gmx rms</code>","text":"<p>To perform RMSD analysis:</p> <pre><code>gmx rms -f trajectory.xtc -s topology.tpr -o rmsd.xvg\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-tu</code>: time units (default is ps)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> <li><code>-skip</code>: number of frames to skip, useful for large simulations</li> </ul> <p>You will be prompted to select two groups, one for least squares fit and one for the RMSD calculations. Select <code>Backbone</code> for both of these.</p> <p>This will output an XVG file that can be visualized using Grace or Python.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-rms/#using-gmx-rmsf","title":"Using <code>gmx rmsf</code>","text":"<p>To perform RMSF analysis:</p> <pre><code>gmx rmsf -f trajectory.xtc -s topology.tpr -o rmsf.xvg -res\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> <li><code>-skip</code>: number of frames to skip, useful for large simulations</li> </ul> <p>The <code>-res</code> option is required to calculate the average fluctuation for each residue. Select <code>Backbone</code> when prompted.</p> <p>This will output an XVG file that can be visualized using Grace or Python.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-rms/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx rms</li> <li>gmx rmsf</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-sasa/","title":"Solvent Accessible Surface Area (SASA)","text":""},{"location":"Molecular%20Dynamics/GROMACS/gmx-sasa/#introduction","title":"Introduction","text":"<p>Solvent accessible surface area (SASA) is a measure of how much a protein's surface is able to contact the system's solvent. SASA is reported in square nanometers (nm<sup>2</sup>) and can be plotted against time. Similar to radius of gyration, changes in SASA over time may indicate protein flexibility and stability.</p> SASA graph from one set of simulations. SASA is plotted as square nanometer (nm<sup>2</sup>) versus time (ns). <p>You should have the following files:</p> <ul> <li>Trajectory files (.xtc)</li> <li>Topology file (.tpr)</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-sasa/#using-gmx-sasa","title":"Using <code>gmx sasa</code>","text":"<p>To calculate the solvent accessible surface area:</p> <pre><code>gmx sasa -f trajectory.xtc -s topology.tpr -tu ns -o sasa.xvg -tu ns\n</code></pre> Other options you may find useful <ul> <li><code>-n</code>: index file to be used (see Creating Index Files)</li> <li><code>-b</code> and <code>-e</code>: the frames to begin and end</li> <li><code>-tv</code>: outputs the total volume and density as a function of time</li> </ul> <p>When prompted, select the group that you wish to analyze.</p> <p>This will output an XVG file of total SASA versus time that can be visualized using Grace or Python.</p>"},{"location":"Molecular%20Dynamics/GROMACS/gmx-sasa/#additional-resources","title":"Additional Resources","text":"<ul> <li>gmx sasa</li> </ul>"},{"location":"Molecular%20Dynamics/GROMACS/misc/","title":"Miscellaneous functions","text":"<p>Annotations (1) differ from footnotes<sup>1</sup> and can be used to add lil notes.</p> <ol> <li> <p>This is an annotation! (1)</p> <ol> <li>This is also an annotation \ud83d\ude32</li> </ol> </li> </ol> <p>The documentation also has some other cool useful things.</p>"},{"location":"Molecular%20Dynamics/GROMACS/misc/#examples-of-code","title":"Examples of Code","text":""},{"location":"Molecular%20Dynamics/GROMACS/misc/#code-blocks-with-syntax-highlighting","title":"Code blocks with syntax highlighting","text":"bash<pre><code>module load apps site/infer/easybuild/setup\nmodule load CMake/3.15.3-GCCcore-8.3.0\nmodule load CUDA/10.1.243-GCC-8.3.0\n\nexport MODULEPATH=$MODULEPATH:/projects/bevanlab/software/infer/modules/modules/infer-skylake/all\nmodule load gromacs-v100/2020.4\n</code></pre> python<pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nfrom shapely import geometry, ops\n\ndef gather_data():\n    ...\n\nif __name__ == '__main__':\n    gather_data()\n</code></pre> <ol> <li> <p>This is a footnote!\u00a0\u21a9</p> </li> </ol>"},{"location":"Python%20Fundamentals/python/","title":"Python Homepage","text":""},{"location":"Python%20Fundamentals/python/#welcome","title":"Welcome!","text":"<p>Python, an widely-used and versatile programming language, is one of the most popular programming languages world-wide. Because of this, being able to read, write, modify, and troubleshoot Python syntax is an invaluable skill regardless of your intended career path. </p> <p>There is almost always multiple ways to solve the same problem within Python. This could involve using solely pure Python code, utilizing externally written code (often called Packages), or more likely will be a combination of both. </p> <p>In the following pages we will highlight packages commonly used in our labs. These will primarily show how the code must be written to obtain specific outputs. In short, this means we will be overviewing specific routes to solve specific problems. As always, reach out to a lab lead or mentor as questions arise. </p>"},{"location":"Python%20Fundamentals/matplotlib/plotting/","title":"matplotlib","text":""},{"location":"Python%20Fundamentals/matplotlib/plotting/#bar-charts","title":"Bar charts","text":"python<pre><code>import matplotlib.pyplot as plt\n\n# Social media platforms and their user counts (in millions)\nplatforms = ['Facebook', 'Instagram', 'Twitter', 'LinkedIn', 'Snapchat']\nusers = [2740, 1220, 396, 774, 498]\n\n# Creating the bar chart\nplt.bar(platforms, users, color='skyblue')\n\n# Adding title and labels\nplt.title('Social Media Users (in millions)')\nplt.xlabel('Platforms')\nplt.ylabel('Users')\n\n# Display the chart\nplt.show()\n</code></pre>"}]}